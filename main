from ursina import *
# import random - idk czy to bedzie potrzebne
import noise
from ursina.prefabs.first_person_controller import FirstPersonController
app = Ursina()
player = FirstPersonController()
Sky()

window.exit_button.visible = False #nie widać x w rogu full screen zabawa

def update():
  #klikanie myszą aktywuje funkcje zmiany pozycji ręki
  if held_keys['left mouse'] or held_keys['right mouse']:
    hand.action()
  else:
    hand.rest()
# prosiak walking
  pig.walk()

def input(key):
  for box in boxes:
    if box.hovered:
      if key == 'right mouse down':
        new = Button(color=color.green, model='cube', position=box.position + mouse.normal,
                    texture='grass_block_top.png', parent=scene, origin_y=0.5)
        boxes.append(new)
      if key == 'left mouse down':
        boxes.remove(box)
        destroy(box)
      
  #jak naciśniesz escape to wyłącza mc (pozniej jakies ostrzezenie dodam moze)
  if key == 'escape':
    application.quit()

#normal_grass_and_stone 
boxes = []
trees=[] 
#generacja_terenu
for i in range(20):
    for j in range(20):
        box = Button(color=color.white, model='cube', position=(j,-3,i),
            texture='stone.png', parent=scene, origin_y=0.5)
        boxes.append(box)

for i in range(20):
    for j in range(20):
        box = Button(color=color.white, model='cube', position=(j,-1,i),
            texture='dirt.png', parent=scene, origin_y=0.5)
        boxes.append(box)

for i in range(20):
    for j in range(20):
        box = Button(color=color.green, model='cube', position=(j,0,i),
            texture='grass_block_top.png', parent=scene, origin_y=0.5)
        boxes.append(box)

#generacja drzewek
for i in range(20):
    for j in range(20):
       los=random.randint(1,3)
       if i%5==0 and j%5==0 and los==1:
            height=int(noise.pnoise2(i/20, j/20, octaves=6)*7)
            for k in range(height+1, height+4):
                tree=Entity(model='cube', position=(j,k,i),
                              texture='tree.jpeg', parent=scene, origin_y=0.5, collider='box')
                trees.append(tree)
                liscie = Entity(model='cube', position=(j, k + 1, i),
                              texture='liscie.png', parent=scene, origin_y=0.5)
                trees.append(liscie)

                
#fancy_grass_gorki_pagorki_i_inne_doly
for i in range(20):
    for j in range(20):
        height = int(noise.pnoise2(i / 20, j / 20, octaves=6) * 7)
        for k in range(1, height + 1):
            box = Button(color=color.green, model='cube', position=(j,k,i),
                texture='grass_block_top.png', parent=scene, origin_y=0.5)
            boxes.append(box)
 
        
#reka 
class Hand(Entity):
  def __init__(self):
    super().__init__(parent=camera.ui,model='cube',scale=(0.16,0.6,0.15),color=color.white,
                     texture='handy',rotation=(40,340,0),position=(0.45,-0.4))
    
  def action(self):
    self.position=(0.35,-0.37)

  def rest(self):
    self.position=(0.45,-0.4)

# klasa na prosiaka
class Piggy(Entity):
  def __init__(self):
    super().__init__()
    self.body=Entity(parent=scene, model='cube',scale=(1.2,0.6,0.8), position=(5,0.7,5), texture='pig_bodx3', collider='box')
    self.head=Entity(parent=self.body, model='cube', scale=(0.45,0.9,0.8), position=(0.6,0.3,0),texture='pig_bodx3')
    Entity(parent=self.head, model='plane', rotation=(-90,-90,0), position=(0.51,0,0),texture='piggy')
    Entity(parent=self.head, model='cube', scale=(0.2,0.4,0.5), position=(0.6,-0.2,0),texture='pig_bodx3')
    Entity(parent=self.head, model='cube', scale=(0.4,0.5,0.15), position=(0,-0.1,0.5),texture='pig_bodx3', rotation=(-20,0,0))
    Entity(parent=self.head, model='cube', scale=(0.4,0.5,0.15), position=(0,-0.1,-0.5),texture='pig_bodx3', rotation=(20,0,0))
    self.leg1=Entity(parent=self.body, model='cube', scale=(0.2,0.55,0.3), position=(0.35,-0.5,0.25),texture='pig_bodx3')
    self.leg2=Entity(parent=self.body,model='cube', scale=(0.2,0.55,0.3), position=(0.35,-0.5,-0.25),texture='pig_bodx3')
    self.leg3=Entity(parent=self.body,model='cube', scale=(0.2,0.55,0.3), position=(-0.35,-0.5,-0.25),texture='pig_bodx3')
    self.leg4=Entity(parent=self.body,model='cube', scale=(0.2,0.55,0.3), position=(-0.35,-0.5,0.25),texture='pig_bodx3')
  
# animacja nóg podczas chodzenia
  def legs_rot_section1(self):
    self.leg1.rotation_z+=time.dt*100
    self.leg3.rotation_z+=time.dt*100
    self.leg2.rotation_z-=time.dt*100
    self.leg4.rotation_z-=time.dt*100
  
# animacja nóg podczas chodzenia
  def legs_rot_section2(self):
    self.leg1.rotation_z-=time.dt*100
    self.leg3.rotation_z-=time.dt*100
    self.leg2.rotation_z+=time.dt*100
    self.leg4.rotation_z+=time.dt*100

# animacja nóg podczas chodzenia
  def legs(self):
    global m
    m+=1
    num_frame=200
    n=m%num_frame
    if n<num_frame//2:
      pig.legs_rot_section1()
    else:
      pig.legs_rot_section2()

# obrót + pójście naprzód
  def rotation_90(self, rotation):
    self.body.rotation_y=rotation
    self.body.position += self.body.right * time.dt * 0.5

# chodzenie oparte na pójsciu przed siebie i obracie
  def walking(self):
    global m
    m+=1
    num_frame=800
    n=m%num_frame
    if n<num_frame//4:
      pig.rotation_90(0)
      pig.legs()
    elif n<(num_frame//4)+200:
      pig.rotation_90(90)
      pig.legs()
    elif n<(num_frame//4)+400:
      pig.rotation_90(180)
      pig.legs()
    else:
      pig.rotation_90(270)
      pig.legs()

# jak się zachować po napotkaniu na przeszkode
  def walk(self):
    hit_info = self.body.intersects()
    if hit_info.hit:
      self.body.x+=.5
      self.body.rotation_y=90
    else:
      pig.walking()
          



pig=Piggy()
m=0
hand=Hand()

app.run()

